"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[9215],{8453(n,e,i){i.d(e,{R:()=>a,x:()=>s});var r=i(6540);const l={},o=r.createContext(l);function a(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:a(n.components),r.createElement(o.Provider,{value:e},n.children)}},8939(n,e,i){i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-ros2/chapter-4-urdf-modeling","title":"Chapter 4: Modeling the Humanoid Body with URDF","description":"URDF Fundamentals","source":"@site/docs/module-1-ros2/chapter-4-urdf-modeling.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-4-urdf-modeling","permalink":"/Book-Physical-AI-Humanoid-Robotics/docs/module-1-ros2/chapter-4-urdf-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammad-Bilal-Hussain/Book-Physical-AI-Humanoid-Robotics/docs/module-1-ros2/chapter-4-urdf-modeling.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Bridging AI Agents with ROS 2 using rclpy","permalink":"/Book-Physical-AI-Humanoid-Robotics/docs/module-1-ros2/chapter-3-ai-integration"},"next":{"title":"Physical AI & Humanoid Robotics","permalink":"/Book-Physical-AI-Humanoid-Robotics/docs/module-1-ros2"}}');var l=i(4848),o=i(8453);const a={},s="Chapter 4: Modeling the Humanoid Body with URDF",t={},c=[{value:"URDF Fundamentals",id:"urdf-fundamentals",level:2},{value:"Introduction to URDF",id:"introduction-to-urdf",level:3},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"Robot Element",id:"robot-element",level:4},{value:"Link Elements",id:"link-elements",level:4},{value:"Joint Elements",id:"joint-elements",level:4},{value:"Key URDF Concepts",id:"key-urdf-concepts",level:3},{value:"Links",id:"links",level:4},{value:"Joints",id:"joints",level:4},{value:"Materials",id:"materials",level:4},{value:"Transmissions",id:"transmissions",level:4},{value:"URDF in Humanoid Robotics",id:"urdf-in-humanoid-robotics",level:3},{value:"Coordinate Frames",id:"coordinate-frames",level:3},{value:"URDF Best Practices",id:"urdf-best-practices",level:3},{value:"URDF Validation",id:"urdf-validation",level:3},{value:"Relationship to ROS TF",id:"relationship-to-ros-tf",level:3},{value:"Links and Joints in URDF",id:"links-and-joints-in-urdf",level:2},{value:"Understanding Links",id:"understanding-links",level:3},{value:"Link Properties",id:"link-properties",level:4},{value:"Visual Properties",id:"visual-properties",level:5},{value:"Collision Properties",id:"collision-properties",level:5},{value:"Inertial Properties",id:"inertial-properties",level:5},{value:"Understanding Joints",id:"understanding-joints",level:3},{value:"Joint Properties",id:"joint-properties",level:4},{value:"Joint Type",id:"joint-type",level:5},{value:"Parent and Child Links",id:"parent-and-child-links",level:5},{value:"Origin",id:"origin",level:5},{value:"Axis",id:"axis",level:5},{value:"Limits",id:"limits",level:5},{value:"Common Joint Types in Humanoid Robots",id:"common-joint-types-in-humanoid-robots",level:3},{value:"Revolute Joints",id:"revolute-joints",level:4},{value:"Fixed Joints",id:"fixed-joints",level:4},{value:"Link-Joint Relationships",id:"link-joint-relationships",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:4},{value:"Tree Structure",id:"tree-structure",level:4},{value:"Practical Example: Simple Arm",id:"practical-example-simple-arm",level:3},{value:"Best Practices for Links and Joints",id:"best-practices-for-links-and-joints",level:3},{value:"Naming Conventions",id:"naming-conventions",level:4},{value:"Joint Placement",id:"joint-placement",level:4},{value:"Mass and Inertia",id:"mass-and-inertia",level:4},{value:"Limits",id:"limits-1",level:4},{value:"Visual and Collision Properties in URDF",id:"visual-and-collision-properties-in-urdf",level:2},{value:"Introduction to Visual and Collision Elements",id:"introduction-to-visual-and-collision-elements",level:3},{value:"Visual Properties",id:"visual-properties-1",level:3},{value:"Visual Element Structure",id:"visual-element-structure",level:4},{value:"Origin in Visual Elements",id:"origin-in-visual-elements",level:4},{value:"Geometry Types",id:"geometry-types",level:4},{value:"Box",id:"box",level:5},{value:"Cylinder",id:"cylinder",level:5},{value:"Sphere",id:"sphere",level:5},{value:"Mesh",id:"mesh",level:5},{value:"Materials",id:"materials-1",level:4},{value:"Collision Properties",id:"collision-properties-1",level:3},{value:"Collision Element Structure",id:"collision-element-structure",level:4},{value:"Collision Geometry Considerations",id:"collision-geometry-considerations",level:4},{value:"Differences Between Visual and Collision Properties",id:"differences-between-visual-and-collision-properties",level:3},{value:"Visual Properties",id:"visual-properties-2",level:4},{value:"Collision Properties",id:"collision-properties-2",level:4},{value:"Practical Example: Visual and Collision Properties",id:"practical-example-visual-and-collision-properties",level:3},{value:"Best Practices for Visual and Collision Properties",id:"best-practices-for-visual-and-collision-properties",level:3},{value:"For Visual Properties",id:"for-visual-properties",level:4},{value:"For Collision Properties",id:"for-collision-properties",level:4},{value:"Performance Considerations",id:"performance-considerations",level:4},{value:"Advanced Topics",id:"advanced-topics",level:3},{value:"Multiple Visual and Collision Elements",id:"multiple-visual-and-collision-elements",level:4},{value:"Using the Same Geometry for Visual and Collision",id:"using-the-same-geometry-for-visual-and-collision",level:4},{value:"Practical Examples of Humanoid URDF Files",id:"practical-examples-of-humanoid-urdf-files",level:2},{value:"Introduction to Humanoid Robot Modeling",id:"introduction-to-humanoid-robot-modeling",level:3},{value:"Complete Humanoid Robot Example",id:"complete-humanoid-robot-example",level:3},{value:"Analysis of the Humanoid URDF",id:"analysis-of-the-humanoid-urdf",level:3},{value:"Structure",id:"structure",level:4},{value:"Joint Limitations",id:"joint-limitations",level:4},{value:"Mass and Inertia",id:"mass-and-inertia-1",level:4},{value:"Visual and Collision Properties",id:"visual-and-collision-properties",level:4},{value:"Real-World Humanoid Examples",id:"real-world-humanoid-examples",level:3},{value:"NAO Robot Structure",id:"nao-robot-structure",level:4},{value:"ATLAS Robot Structure",id:"atlas-robot-structure",level:4},{value:"Common Patterns in Humanoid URDFs",id:"common-patterns-in-humanoid-urdfs",level:3},{value:"Head Structure",id:"head-structure",level:4},{value:"Limb Structure",id:"limb-structure",level:4},{value:"Tips for Creating Humanoid URDFs",id:"tips-for-creating-humanoid-urdfs",level:3},{value:"Xacro for Parameterized Descriptions",id:"xacro-for-parameterized-descriptions",level:2},{value:"Introduction to Xacro",id:"introduction-to-xacro",level:3},{value:"Basic Xacro Concepts",id:"basic-xacro-concepts",level:3},{value:"Including Xacro",id:"including-xacro",level:4},{value:"Properties and Constants",id:"properties-and-constants",level:4},{value:"Mathematical Expressions",id:"mathematical-expressions",level:4},{value:"Xacro Macros",id:"xacro-macros",level:3},{value:"Practical Xacro Example for Humanoid Robot",id:"practical-xacro-example-for-humanoid-robot",level:3},{value:"Advanced Xacro Features",id:"advanced-xacro-features",level:3},{value:"Conditional Statements",id:"conditional-statements",level:4},{value:"Including Other Xacro Files",id:"including-other-xacro-files",level:4},{value:"Loops",id:"loops",level:4},{value:"Benefits of Using Xacro for Humanoid Robots",id:"benefits-of-using-xacro-for-humanoid-robots",level:3},{value:"Reduced Repetition",id:"reduced-repetition",level:4},{value:"Parameterization",id:"parameterization",level:4},{value:"Modularity",id:"modularity",level:4},{value:"Readability",id:"readability",level:4},{value:"Converting Xacro to URDF",id:"converting-xacro-to-urdf",level:3},{value:"Best Practices for Xacro",id:"best-practices-for-xacro",level:3},{value:"URDF Integration with Simulation Environments",id:"urdf-integration-with-simulation-environments",level:2},{value:"Introduction to Simulation Integration",id:"introduction-to-simulation-integration",level:3},{value:"Gazebo Simulation Environment",id:"gazebo-simulation-environment",level:3},{value:"Gazebo-Specific Tags in URDF",id:"gazebo-specific-tags-in-urdf",level:4},{value:"Gazebo Plugins",id:"gazebo-plugins",level:4},{value:"Joint Transmission Elements",id:"joint-transmission-elements",level:4},{value:"Integration Process",id:"integration-process",level:3},{value:"1. Model Conversion",id:"1-model-conversion",level:4},{value:"2. Physics Properties",id:"2-physics-properties",level:4},{value:"3. Sensor Integration",id:"3-sensor-integration",level:4},{value:"Other Simulation Environments",id:"other-simulation-environments",level:3},{value:"Webots",id:"webots",level:4},{value:"Mujoco",id:"mujoco",level:4},{value:"PyBullet",id:"pybullet",level:4},{value:"Best Practices for Simulation Integration",id:"best-practices-for-simulation-integration",level:3},{value:"1. Accurate Physical Properties",id:"1-accurate-physical-properties",level:4},{value:"2. Simplified Collision Models",id:"2-simplified-collision-models",level:4},{value:"3. Proper Joint Limits",id:"3-proper-joint-limits",level:4},{value:"4. Sensor Placement",id:"4-sensor-placement",level:4},{value:"Simulation-Specific Considerations for Humanoid Robots",id:"simulation-specific-considerations-for-humanoid-robots",level:3},{value:"Balance and Stability",id:"balance-and-stability",level:4},{value:"Complex Kinematics",id:"complex-kinematics",level:4},{value:"Computational Performance",id:"computational-performance",level:4},{value:"Launching Robots in Simulation",id:"launching-robots-in-simulation",level:3},{value:"Troubleshooting Simulation Issues",id:"troubleshooting-simulation-issues",level:3},{value:"Robot Falls Through Ground",id:"robot-falls-through-ground",level:4},{value:"Joints Behaving Unexpectedly",id:"joints-behaving-unexpectedly",level:4},{value:"Poor Simulation Performance",id:"poor-simulation-performance",level:4},{value:"Sample URDF Code Snippets",id:"sample-urdf-code-snippets",level:2},{value:"Basic Robot Structure",id:"basic-robot-structure",level:3},{value:"Complete Joint Example",id:"complete-joint-example",level:3},{value:"Humanoid Torso Example",id:"humanoid-torso-example",level:3},{value:"Sensor Attachment Example",id:"sensor-attachment-example",level:3},{value:"Transmission Example",id:"transmission-example",level:3},{value:"Gazebo-Specific Properties",id:"gazebo-specific-properties",level:3},{value:"Complete Humanoid Hand Example",id:"complete-humanoid-hand-example",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.header,{children:(0,l.jsx)(e.h1,{id:"chapter-4-modeling-the-humanoid-body-with-urdf",children:"Chapter 4: Modeling the Humanoid Body with URDF"})}),"\n",(0,l.jsx)(e.h2,{id:"urdf-fundamentals",children:"URDF Fundamentals"}),"\n",(0,l.jsx)(e.h3,{id:"introduction-to-urdf",children:"Introduction to URDF"}),"\n",(0,l.jsx)(e.p,{children:"URDF stands for Unified Robot Description Format. It is an XML-based format used to describe robot models in ROS. URDF defines the physical and visual properties of a robot, including its kinematic structure, visual appearance, and collision properties. For humanoid robots in Physical AI systems, URDF is essential for simulation, visualization, and control."}),"\n",(0,l.jsx)(e.p,{children:"URDF allows developers to represent a robot as a collection of rigid bodies (links) connected by joints. This representation is crucial for:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Robot simulation in environments like Gazebo"}),"\n",(0,l.jsx)(e.li,{children:"Kinematic analysis and inverse kinematics calculations"}),"\n",(0,l.jsx)(e.li,{children:"Visualization in tools like RViz"}),"\n",(0,l.jsx)(e.li,{children:"Motion planning and collision detection"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,l.jsx)(e.p,{children:"A URDF file consists of several key elements:"}),"\n",(0,l.jsx)(e.h4,{id:"robot-element",children:"Robot Element"}),"\n",(0,l.jsxs)(e.p,{children:["The root element of every URDF file is the ",(0,l.jsx)(e.code,{children:"<robot>"})," tag, which contains the entire robot description:"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<robot name="humanoid_robot">\n  \x3c!-- Robot components go here --\x3e\n</robot>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"link-elements",children:"Link Elements"}),"\n",(0,l.jsx)(e.p,{children:"Links represent rigid bodies in the robot. Each link has physical and visual properties:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="base_link">\n  <visual>\n    <geometry>\n      <cylinder length="0.6" radius="0.2"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 0.8 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder length="0.6" radius="0.2"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="10"/>\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n  </inertial>\n</link>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"joint-elements",children:"Joint Elements"}),"\n",(0,l.jsx)(e.p,{children:"Joints connect links and define the kinematic relationship between them:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<joint name="base_to_upper_leg" type="revolute">\n  <parent link="base_link"/>\n  <child link="upper_leg"/>\n  <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"key-urdf-concepts",children:"Key URDF Concepts"}),"\n",(0,l.jsx)(e.h4,{id:"links",children:"Links"}),"\n",(0,l.jsx)(e.p,{children:"Links represent the rigid parts of the robot. Each link can have:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Visual properties"}),": How the link appears in simulation and visualization"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Collision properties"}),": How the link interacts with other objects in collision detection"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Inertial properties"}),": Mass, center of mass, and inertia tensor for physics simulation"]}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"joints",children:"Joints"}),"\n",(0,l.jsx)(e.p,{children:"Joints define the connection between links and specify how they can move relative to each other. Joint types include:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Revolute"}),": Rotational joint with one degree of freedom"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Continuous"}),": Like revolute but unlimited rotation"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Prismatic"}),": Linear sliding joint"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Fixed"}),": No movement between links"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Floating"}),": Six degrees of freedom"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Planar"}),": Movement in a plane"]}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"materials",children:"Materials"}),"\n",(0,l.jsx)(e.p,{children:"Materials define the visual appearance of links, including color and texture."}),"\n",(0,l.jsx)(e.h4,{id:"transmissions",children:"Transmissions"}),"\n",(0,l.jsx)(e.p,{children:"Transmissions define how actuators (motors) connect to joints, specifying the mechanical relationship between motor and joint."}),"\n",(0,l.jsx)(e.h3,{id:"urdf-in-humanoid-robotics",children:"URDF in Humanoid Robotics"}),"\n",(0,l.jsx)(e.p,{children:"For humanoid robots, URDF is particularly important because it captures the complex kinematic structure of the human-like body. A humanoid robot typically includes:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Torso"}),": The central body with links for chest, waist, and pelvis"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Head"}),": Neck and head links with appropriate joint limits"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Arms"}),": Shoulder, elbow, and wrist joints with appropriate degrees of freedom"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Legs"}),": Hip, knee, and ankle joints for locomotion"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Hands/Feet"}),": For manipulation and stable stance"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"coordinate-frames",children:"Coordinate Frames"}),"\n",(0,l.jsx)(e.p,{children:"URDF uses the right-hand rule for coordinate systems:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"X-axis"}),": Forward (anterior) direction"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Y-axis"}),": Left (lateral) direction"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Z-axis"}),": Up (superior) direction"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Joint axes define the direction of motion. For revolute joints, positive rotation follows the right-hand rule around the axis."}),"\n",(0,l.jsx)(e.h3,{id:"urdf-best-practices",children:"URDF Best Practices"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Meaningful Names"}),": Use descriptive names for links and joints that reflect their function"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Proper Root Link"}),": Define a clear base link that serves as the reference frame"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Kinematic Chain"}),": Ensure all links are connected in a proper kinematic chain"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Joint Limits"}),": Specify realistic joint limits based on physical constraints"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Mass Properties"}),": Accurate mass and inertia values for realistic simulation"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Collision vs. Visual"}),": Use simplified geometries for collision detection to improve performance"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"urdf-validation",children:"URDF Validation"}),"\n",(0,l.jsxs)(e.p,{children:["URDF files should be validated to ensure they are well-formed and represent a physically plausible robot. ROS provides tools like ",(0,l.jsx)(e.code,{children:"check_urdf"})," to validate URDF files."]}),"\n",(0,l.jsx)(e.h3,{id:"relationship-to-ros-tf",children:"Relationship to ROS TF"}),"\n",(0,l.jsx)(e.p,{children:"URDF defines the static transforms between robot links, which ROS's TF (Transform) system uses to maintain the spatial relationship between different parts of the robot over time."}),"\n",(0,l.jsx)(e.p,{children:"Understanding URDF fundamentals is essential for creating accurate robot models that can be used effectively in simulation, visualization, and control systems for humanoid robots in Physical AI applications."}),"\n",(0,l.jsx)(e.h2,{id:"links-and-joints-in-urdf",children:"Links and Joints in URDF"}),"\n",(0,l.jsx)(e.h3,{id:"understanding-links",children:"Understanding Links"}),"\n",(0,l.jsx)(e.p,{children:"In URDF, a link represents a rigid body part of the robot. Each link is a fundamental building block that has physical properties and can be connected to other links through joints. Links are the static components of a robot model that define its structure."}),"\n",(0,l.jsx)(e.h4,{id:"link-properties",children:"Link Properties"}),"\n",(0,l.jsx)(e.p,{children:"Each link can have several important properties:"}),"\n",(0,l.jsx)(e.h5,{id:"visual-properties",children:"Visual Properties"}),"\n",(0,l.jsx)(e.p,{children:"The visual element defines how the link appears in simulation and visualization tools:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n  <material name="red">\n    <color rgba="1 0 0 1"/>\n  </material>\n</visual>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Origin"}),": Specifies the position and orientation of the visual geometry relative to the link's frame"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Geometry"}),": Defines the shape (box, cylinder, sphere, mesh)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Material"}),": Specifies color and appearance properties"]}),"\n"]}),"\n",(0,l.jsx)(e.h5,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,l.jsx)(e.p,{children:"The collision element defines how the link interacts with other objects in collision detection:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.1"/>\n  </geometry>\n</collision>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Collision geometry can be simplified compared to visual geometry to improve performance."}),"\n",(0,l.jsx)(e.h5,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,l.jsx)(e.p,{children:"The inertial element defines the physical properties for dynamics simulation:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<inertial>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <mass value="1.0"/>\n  <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n</inertial>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Mass"}),": The mass of the link in kilograms"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Inertia"}),": The 3x3 inertia matrix describing how mass is distributed"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"understanding-joints",children:"Understanding Joints"}),"\n",(0,l.jsx)(e.p,{children:"Joints connect links and define the kinematic relationship between them. They specify how two links can move relative to each other."}),"\n",(0,l.jsx)(e.h4,{id:"joint-properties",children:"Joint Properties"}),"\n",(0,l.jsx)(e.p,{children:"Each joint has several important properties:"}),"\n",(0,l.jsx)(e.h5,{id:"joint-type",children:"Joint Type"}),"\n",(0,l.jsx)(e.p,{children:"The type attribute defines the kind of motion allowed:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Fixed"}),": No motion between links (0 DOF)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Revolute"}),": Single rotational axis with limits (1 DOF)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Continuous"}),": Single rotational axis without limits (1 DOF)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Prismatic"}),": Single linear axis with limits (1 DOF)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Floating"}),": Six degrees of freedom (6 DOF)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Planar"}),": Motion in a plane (3 DOF)"]}),"\n"]}),"\n",(0,l.jsx)(e.h5,{id:"parent-and-child-links",children:"Parent and Child Links"}),"\n",(0,l.jsx)(e.p,{children:"Joints connect exactly two links:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent link="parent_link_name"/>\n  <child link="child_link_name"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h5,{id:"origin",children:"Origin"}),"\n",(0,l.jsx)(e.p,{children:"Specifies the position and orientation of the joint relative to the parent link:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<origin xyz="1.0 0 0" rpy="0 0 0"/>\n'})}),"\n",(0,l.jsx)(e.h5,{id:"axis",children:"Axis"}),"\n",(0,l.jsx)(e.p,{children:"Defines the axis of motion for revolute and prismatic joints:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<axis xyz="0 0 1"/>\n'})}),"\n",(0,l.jsx)(e.h5,{id:"limits",children:"Limits"}),"\n",(0,l.jsx)(e.p,{children:"For revolute and prismatic joints, limits define the range of motion:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Lower/Upper"}),": Range of motion in radians (revolute) or meters (prismatic)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Effort"}),": Maximum torque/force in N-m or N"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Velocity"}),": Maximum velocity in rad/s or m/s"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"common-joint-types-in-humanoid-robots",children:"Common Joint Types in Humanoid Robots"}),"\n",(0,l.jsx)(e.h4,{id:"revolute-joints",children:"Revolute Joints"}),"\n",(0,l.jsx)(e.p,{children:"Most common in humanoid robots, representing rotational joints like elbows, knees, and shoulders:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<joint name="elbow_joint" type="revolute">\n  <parent link="upper_arm"/>\n  <child link="lower_arm"/>\n  <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-2.356" upper="2.356" effort="50" velocity="2"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"fixed-joints",children:"Fixed Joints"}),"\n",(0,l.jsx)(e.p,{children:"Used for attaching sensors or other components that don't move relative to their parent:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<joint name="camera_joint" type="fixed">\n  <parent link="head"/>\n  <child link="camera_frame"/>\n  <origin xyz="0.1 0 0.05" rpy="0 0 0"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"link-joint-relationships",children:"Link-Joint Relationships"}),"\n",(0,l.jsx)(e.h4,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,l.jsx)(e.p,{children:"Links and joints form kinematic chains that define the robot's structure. A humanoid robot typically has multiple kinematic chains:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Torso chain"}),": Base to head"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Arm chains"}),": Torso to hands (2 chains)"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Leg chains"}),": Torso to feet (2 chains)"]}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"tree-structure",children:"Tree Structure"}),"\n",(0,l.jsx)(e.p,{children:"URDF models form a tree structure with a single root link. Each link (except the root) has exactly one parent, but can have multiple children."}),"\n",(0,l.jsx)(e.h3,{id:"practical-example-simple-arm",children:"Practical Example: Simple Arm"}),"\n",(0,l.jsx)(e.p,{children:"Here's a complete example of a simple 2-DOF arm:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="base_link">\n  <inertial>\n    <mass value="1"/>\n    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n  </inertial>\n  <visual>\n    <geometry>\n      <cylinder radius="0.1" length="0.2"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 1 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.1" length="0.2"/>\n    </geometry>\n  </collision>\n</link>\n\n<link name="upper_arm">\n  <inertial>\n    <mass value="2"/>\n    <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.02"/>\n  </inertial>\n  <visual>\n    <geometry>\n      <cylinder radius="0.05" length="0.5"/>\n    </geometry>\n    <material name="red">\n      <color rgba="1 0 0 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.05" length="0.5"/>\n    </geometry>\n  </collision>\n</link>\n\n<link name="lower_arm">\n  <inertial>\n    <mass value="1.5"/>\n    <inertia ixx="0.08" ixy="0" ixz="0" iyy="0.08" iyz="0" izz="0.01"/>\n  </inertial>\n  <visual>\n    <geometry>\n      <cylinder radius="0.04" length="0.4"/>\n    </geometry>\n    <material name="green">\n      <color rgba="0 1 0 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.04" length="0.4"/>\n    </geometry>\n  </collision>\n</link>\n\n<joint name="shoulder_joint" type="revolute">\n  <parent link="base_link"/>\n  <child link="upper_arm"/>\n  <origin xyz="0 0 0.1" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n\n<joint name="elbow_joint" type="revolute">\n  <parent link="upper_arm"/>\n  <child link="lower_arm"/>\n  <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="80" velocity="1"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"best-practices-for-links-and-joints",children:"Best Practices for Links and Joints"}),"\n",(0,l.jsx)(e.h4,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["Use descriptive names that indicate the function (e.g., ",(0,l.jsx)(e.code,{children:"left_elbow_joint"}),")"]}),"\n",(0,l.jsx)(e.li,{children:"Follow a consistent naming scheme throughout the model"}),"\n",(0,l.jsx)(e.li,{children:"Use underscores to separate words"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"joint-placement",children:"Joint Placement"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Place joints at the physical pivot point of the connection"}),"\n",(0,l.jsx)(e.li,{children:"Ensure joint axes align with the intended direction of motion"}),"\n",(0,l.jsx)(e.li,{children:"Use appropriate joint types for the intended motion"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"mass-and-inertia",children:"Mass and Inertia"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Use realistic mass values based on the actual robot"}),"\n",(0,l.jsx)(e.li,{children:"Calculate inertia tensors based on the geometry and mass distribution"}),"\n",(0,l.jsx)(e.li,{children:"Consider the payload when calculating masses for end-effectors"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"limits-1",children:"Limits"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Set realistic joint limits based on the physical robot"}),"\n",(0,l.jsx)(e.li,{children:"Include safety margins in the limits"}),"\n",(0,l.jsx)(e.li,{children:"Consider the effect of joint limits on motion planning"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Understanding how to properly define links and joints in URDF is crucial for creating accurate robot models that work well in simulation, visualization, and control systems for humanoid robots."}),"\n",(0,l.jsx)(e.h2,{id:"visual-and-collision-properties-in-urdf",children:"Visual and Collision Properties in URDF"}),"\n",(0,l.jsx)(e.h3,{id:"introduction-to-visual-and-collision-elements",children:"Introduction to Visual and Collision Elements"}),"\n",(0,l.jsx)(e.p,{children:"In URDF, each link can have both visual and collision properties that define how the robot appears and interacts with its environment. These properties are crucial for simulation, visualization, and collision detection in humanoid robots."}),"\n",(0,l.jsx)(e.p,{children:"The visual element defines how the robot appears in simulation and visualization tools, while the collision element defines how the robot interacts with other objects in collision detection and physics simulation."}),"\n",(0,l.jsx)(e.h3,{id:"visual-properties-1",children:"Visual Properties"}),"\n",(0,l.jsx)(e.p,{children:"The visual element specifies how a link appears in visualization tools like RViz and simulation environments like Gazebo."}),"\n",(0,l.jsx)(e.h4,{id:"visual-element-structure",children:"Visual Element Structure"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    \x3c!-- Geometry definition --\x3e\n  </geometry>\n  <material name="material_name">\n    \x3c!-- Material definition --\x3e\n  </material>\n</visual>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"origin-in-visual-elements",children:"Origin in Visual Elements"}),"\n",(0,l.jsx)(e.p,{children:"The origin element specifies the position and orientation of the visual geometry relative to the link's frame:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<origin xyz="0.1 0 0.05" rpy="0 0 1.57"/>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"xyz"}),": Position offset (x, y, z) in meters"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"rpy"}),": Orientation as roll, pitch, yaw in radians"]}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"geometry-types",children:"Geometry Types"}),"\n",(0,l.jsx)(e.p,{children:"URDF supports several geometry types for visual representation:"}),"\n",(0,l.jsx)(e.h5,{id:"box",children:"Box"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<geometry>\n  <box size="0.1 0.2 0.3"/>\n</geometry>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Defines a box with specified dimensions (width, depth, height)."}),"\n",(0,l.jsx)(e.h5,{id:"cylinder",children:"Cylinder"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<geometry>\n  <cylinder radius="0.05" length="0.3"/>\n</geometry>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Defines a cylinder with specified radius and length."}),"\n",(0,l.jsx)(e.h5,{id:"sphere",children:"Sphere"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<geometry>\n  <sphere radius="0.05"/>\n</geometry>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Defines a sphere with specified radius."}),"\n",(0,l.jsx)(e.h5,{id:"mesh",children:"Mesh"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<geometry>\n  <mesh filename="package://robot_description/meshes/link.stl" scale="1 1 1"/>\n</geometry>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Defines a complex shape using a mesh file. The filename can be a package-relative path or an absolute path."}),"\n",(0,l.jsx)(e.h4,{id:"materials-1",children:"Materials"}),"\n",(0,l.jsx)(e.p,{children:"Materials define the color and appearance of visual elements:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<material name="red">\n  <color rgba="1 0 0 1"/>\n</material>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"name"}),": A unique identifier for the material"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"color"}),": RGBA values (Red, Green, Blue, Alpha) from 0 to 1"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Alternatively, materials can reference textures:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<material name="texture_material">\n  <texture filename="package://robot_description/materials/textures/texture.png"/>\n</material>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"collision-properties-1",children:"Collision Properties"}),"\n",(0,l.jsx)(e.p,{children:"The collision element defines how a link interacts with other objects in collision detection and physics simulation."}),"\n",(0,l.jsx)(e.h4,{id:"collision-element-structure",children:"Collision Element Structure"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    \x3c!-- Geometry definition --\x3e\n  </geometry>\n</collision>\n'})}),"\n",(0,l.jsx)(e.p,{children:"The structure is similar to the visual element, but collision elements are used exclusively for physics calculations."}),"\n",(0,l.jsx)(e.h4,{id:"collision-geometry-considerations",children:"Collision Geometry Considerations"}),"\n",(0,l.jsx)(e.p,{children:"Collision geometry should be:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Simple"}),": Use simple shapes when possible to improve performance"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Conservative"}),": Ensure collision geometry encompasses the actual physical link"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Efficient"}),": Balance accuracy with computational cost"]}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"differences-between-visual-and-collision-properties",children:"Differences Between Visual and Collision Properties"}),"\n",(0,l.jsx)(e.p,{children:"While visual and collision elements have similar structures, they serve different purposes:"}),"\n",(0,l.jsx)(e.h4,{id:"visual-properties-2",children:"Visual Properties"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Used for rendering and visualization"}),"\n",(0,l.jsx)(e.li,{children:"Can use complex meshes for realistic appearance"}),"\n",(0,l.jsx)(e.li,{children:"Performance impact is mainly on graphics rendering"}),"\n",(0,l.jsx)(e.li,{children:"Focus on appearance rather than accuracy"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"collision-properties-2",children:"Collision Properties"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Used for collision detection and physics simulation"}),"\n",(0,l.jsx)(e.li,{children:"Should use simplified geometry for performance"}),"\n",(0,l.jsx)(e.li,{children:"Performance impact is on physics calculations"}),"\n",(0,l.jsx)(e.li,{children:"Focus on accurate collision detection rather than appearance"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"practical-example-visual-and-collision-properties",children:"Practical Example: Visual and Collision Properties"}),"\n",(0,l.jsx)(e.p,{children:"Here's an example showing both visual and collision properties for a humanoid robot link:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="upper_arm">\n  \x3c!-- Inertial properties for physics simulation --\x3e\n  <inertial>\n    <mass value="2.5"/>\n    <origin xyz="0 0 0.15" rpy="0 0 0"/>\n    <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.001"/>\n  </inertial>\n\n  \x3c!-- Visual properties for appearance --\x3e\n  <visual>\n    <origin xyz="0 0 0.15" rpy="0 0 0"/>\n    <geometry>\n      <mesh filename="package://humanoid_robot/meshes/upper_arm.dae"/>\n    </geometry>\n    <material name="arm_material">\n      <color rgba="0.8 0.8 0.8 1"/>\n    </material>\n  </visual>\n\n  \x3c!-- Collision properties for physics --\x3e\n  <collision>\n    <origin xyz="0 0 0.15" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.06" length="0.3"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,l.jsx)(e.p,{children:"In this example:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"The visual element uses a detailed mesh for realistic appearance"}),"\n",(0,l.jsx)(e.li,{children:"The collision element uses a simple cylinder for efficient collision detection"}),"\n",(0,l.jsx)(e.li,{children:"Both elements are positioned similarly but could differ if needed"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"best-practices-for-visual-and-collision-properties",children:"Best Practices for Visual and Collision Properties"}),"\n",(0,l.jsx)(e.h4,{id:"for-visual-properties",children:"For Visual Properties"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Use high-quality meshes for important visible parts"}),"\n",(0,l.jsx)(e.li,{children:"Apply consistent materials across the robot"}),"\n",(0,l.jsx)(e.li,{children:"Consider using package-relative paths for mesh files"}),"\n",(0,l.jsx)(e.li,{children:"Optimize mesh complexity for visualization performance"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"for-collision-properties",children:"For Collision Properties"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Use simple geometric shapes when possible (boxes, cylinders, spheres)"}),"\n",(0,l.jsx)(e.li,{children:"Ensure collision geometry fully encompasses the physical link"}),"\n",(0,l.jsx)(e.li,{children:"Consider using multiple collision elements for complex shapes"}),"\n",(0,l.jsx)(e.li,{children:"Balance accuracy with simulation performance"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Complex visual meshes don't significantly impact physics performance"}),"\n",(0,l.jsx)(e.li,{children:"Complex collision meshes significantly impact physics performance"}),"\n",(0,l.jsx)(e.li,{children:"Use convex hulls or simplified meshes for collision detection"}),"\n",(0,l.jsx)(e.li,{children:"Consider using multiple simple shapes instead of one complex shape"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,l.jsx)(e.h4,{id:"multiple-visual-and-collision-elements",children:"Multiple Visual and Collision Elements"}),"\n",(0,l.jsx)(e.p,{children:"A single link can have multiple visual and collision elements:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="complex_link">\n  <visual name="main_visual">\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.1 0.1 0.1"/>\n    </geometry>\n    <material name="gray">\n      <color rgba="0.5 0.5 0.5 1"/>\n    </material>\n  </visual>\n\n  <visual name="attachment_visual">\n    <origin xyz="0.05 0 0" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.02" length="0.05"/>\n    </geometry>\n    <material name="red">\n      <color rgba="1 0 0 1"/>\n    </material>\n  </visual>\n\n  <collision name="main_collision">\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.1 0.1 0.1"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"using-the-same-geometry-for-visual-and-collision",children:"Using the Same Geometry for Visual and Collision"}),"\n",(0,l.jsx)(e.p,{children:"When visual and collision geometry are identical, you can define the geometry once and reference it:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="simple_link">\n  <visual>\n    <geometry>\n      <sphere radius="0.05"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 1 1"/>\n    </material>\n  </visual>\n\n  <collision>\n    <geometry>\n      <sphere radius="0.05"/>\n    </geometry>\n  </collision>\n</link>\n'})}),"\n",(0,l.jsx)(e.p,{children:"Properly defining visual and collision properties is essential for creating realistic simulations and accurate collision detection in humanoid robots. The balance between visual fidelity and computational efficiency is key to achieving good performance in both visualization and physics simulation."}),"\n",(0,l.jsx)(e.h2,{id:"practical-examples-of-humanoid-urdf-files",children:"Practical Examples of Humanoid URDF Files"}),"\n",(0,l.jsx)(e.h3,{id:"introduction-to-humanoid-robot-modeling",children:"Introduction to Humanoid Robot Modeling"}),"\n",(0,l.jsx)(e.p,{children:"Modeling humanoid robots in URDF requires careful consideration of the complex kinematic structure that mimics the human body. A humanoid robot typically includes a torso, head, two arms, and two legs, each with multiple joints that allow for human-like movement."}),"\n",(0,l.jsx)(e.h3,{id:"complete-humanoid-robot-example",children:"Complete Humanoid Robot Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's a simplified but complete URDF example for a humanoid robot:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n\n  \x3c!-- Base/Fixed link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.15" length="1.0"/>\n      </geometry>\n      <material name="light_gray">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.15" length="1.0"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <inertial>\n      <mass value="8.0"/>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <inertia ixx="0.8" ixy="0.0" ixz="0.0" iyy="0.8" iyz="0.0" izz="0.2"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.2 0.6"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1.0 1.0 1.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.2 0.6"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 1.0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n      <material name="skin_color">\n        <color rgba="0.9 0.8 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.6" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.785" upper="0.785" effort="10" velocity="1.5"/>\n  </joint>\n\n  \x3c!-- Left Arm --\x3e\n  <link name="left_shoulder">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_shoulder_yaw" type="revolute">\n    <parent link="torso"/>\n    <child link="left_shoulder"/>\n    <origin xyz="0.15 0.1 0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="20" velocity="1.0"/>\n  </joint>\n\n  <link name="left_upper_arm">\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_shoulder_pitch" type="revolute">\n    <parent link="left_shoulder"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="20" velocity="1.0"/>\n  </joint>\n\n  <link name="left_lower_arm">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.2"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_elbow" type="revolute">\n    <parent link="left_upper_arm"/>\n    <child link="left_lower_arm"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="15" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Right Arm (similar to left, mirrored) --\x3e\n  <link name="right_shoulder">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_shoulder_yaw" type="revolute">\n    <parent link="torso"/>\n    <child link="right_shoulder"/>\n    <origin xyz="0.15 -0.1 0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="20" velocity="1.0"/>\n  </joint>\n\n  <link name="right_upper_arm">\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_shoulder_pitch" type="revolute">\n    <parent link="right_shoulder"/>\n    <child link="right_upper_arm"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="20" velocity="1.0"/>\n  </joint>\n\n  <link name="right_lower_arm">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.2"/>\n      </geometry>\n      <material name="dark_gray">\n        <color rgba="0.3 0.3 0.3 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_elbow" type="revolute">\n    <parent link="right_upper_arm"/>\n    <child link="right_lower_arm"/>\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="15" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Left Leg --\x3e\n  <link name="left_hip">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.1"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_hip_yaw" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_hip"/>\n    <origin xyz="0 0.1 -0.1" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-0.785" upper="0.785" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="left_thigh">\n    <inertial>\n      <mass value="3.0"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.4"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_hip_pitch" type="revolute">\n    <parent link="left_hip"/>\n    <child link="left_thigh"/>\n    <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="0.2" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="left_shin">\n    <inertial>\n      <mass value="2.5"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.04" ixy="0.0" ixz="0.0" iyy="0.04" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_knee" type="revolute">\n    <parent link="left_thigh"/>\n    <child link="left_shin"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="0" upper="1.57" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="left_foot">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="left_ankle" type="revolute">\n    <parent link="left_shin"/>\n    <child link="left_foot"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-0.5" upper="0.5" effort="20" velocity="0.8"/>\n  </joint>\n\n  \x3c!-- Right Leg (similar to left, mirrored) --\x3e\n  <link name="right_hip">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.1"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_hip_yaw" type="revolute">\n    <parent link="base_link"/>\n    <child link="right_hip"/>\n    <origin xyz="0 -0.1 -0.1" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-0.785" upper="0.785" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="right_thigh">\n    <inertial>\n      <mass value="3.0"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.05" ixy="0.0" ixz="0.0" iyy="0.05" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.4"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.06" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_hip_pitch" type="revolute">\n    <parent link="right_hip"/>\n    <child link="right_thigh"/>\n    <origin xyz="0 0 -0.1" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="0.2" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="right_shin">\n    <inertial>\n      <mass value="2.5"/>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <inertia ixx="0.04" ixy="0.0" ixz="0.0" iyy="0.04" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.4"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_knee" type="revolute">\n    <parent link="right_thigh"/>\n    <child link="right_shin"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="0" upper="1.57" effort="30" velocity="0.8"/>\n  </joint>\n\n  <link name="right_foot">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0.1 0.1 0.1 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0.05 0 -0.05" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.1 0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="right_ankle" type="revolute">\n    <parent link="right_shin"/>\n    <child link="right_foot"/>\n    <origin xyz="0 0 -0.4" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-0.5" upper="0.5" effort="20" velocity="0.8"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"analysis-of-the-humanoid-urdf",children:"Analysis of the Humanoid URDF"}),"\n",(0,l.jsx)(e.p,{children:"This example demonstrates several important concepts for humanoid robot modeling:"}),"\n",(0,l.jsx)(e.h4,{id:"structure",children:"Structure"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"The robot has a hierarchical structure with a base link and multiple kinematic chains"}),"\n",(0,l.jsx)(e.li,{children:"Each limb (arms and legs) forms its own kinematic chain"}),"\n",(0,l.jsx)(e.li,{children:"The head is connected to the torso via a neck joint"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"joint-limitations",children:"Joint Limitations"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Joint limits are set to realistic values based on human anatomy"}),"\n",(0,l.jsx)(e.li,{children:"Different joints have different types and ranges of motion"}),"\n",(0,l.jsx)(e.li,{children:"Effort and velocity limits are specified for physics simulation"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"mass-and-inertia-1",children:"Mass and Inertia"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Reasonable mass values are assigned to each link"}),"\n",(0,l.jsx)(e.li,{children:"Inertia tensors are estimated based on the geometry and mass"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"visual-and-collision-properties",children:"Visual and Collision Properties"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Simple geometric shapes are used for both visual and collision elements"}),"\n",(0,l.jsx)(e.li,{children:"Colors are used to distinguish different parts of the robot"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"real-world-humanoid-examples",children:"Real-World Humanoid Examples"}),"\n",(0,l.jsx)(e.h4,{id:"nao-robot-structure",children:"NAO Robot Structure"}),"\n",(0,l.jsx)(e.p,{children:"The popular NAO humanoid robot has a similar structure with:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"25 degrees of freedom"}),"\n",(0,l.jsx)(e.li,{children:"Sensors in the head (cameras, microphones, tactile sensors)"}),"\n",(0,l.jsx)(e.li,{children:"Actuated joints in the arms and legs"}),"\n",(0,l.jsx)(e.li,{children:"Feet with pressure sensors"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"atlas-robot-structure",children:"ATLAS Robot Structure"}),"\n",(0,l.jsx)(e.p,{children:"More complex humanoid robots like ATLAS have:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Hydraulic actuation"}),"\n",(0,l.jsx)(e.li,{children:"More complex kinematic structures"}),"\n",(0,l.jsx)(e.li,{children:"Additional sensors and computational units"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"common-patterns-in-humanoid-urdfs",children:"Common Patterns in Humanoid URDFs"}),"\n",(0,l.jsx)(e.h4,{id:"head-structure",children:"Head Structure"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="head">\n  \x3c!-- Head link definition --\x3e\n</link>\n<joint name="neck_joint" type="revolute">\n  <parent link="torso"/>\n  <child link="head"/>\n  \x3c!-- Joint definition --\x3e\n</joint>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"limb-structure",children:"Limb Structure"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Upper segment --\x3e\n<link name="upper_segment">\n  \x3c!-- Link definition --\x3e\n</link>\n\n\x3c!-- Lower segment --\x3e\n<link name="lower_segment">\n  \x3c!-- Link definition --\x3e\n</link>\n\n\x3c!-- Connecting joint --\x3e\n<joint name="connecting_joint" type="revolute">\n  <parent link="upper_segment"/>\n  <child link="lower_segment"/>\n  \x3c!-- Joint definition --\x3e\n</joint>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"tips-for-creating-humanoid-urdfs",children:"Tips for Creating Humanoid URDFs"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Start Simple"}),": Begin with basic geometric shapes and add complexity gradually"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Reference Human Anatomy"}),": Use human joint ranges as a reference for realistic limits"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Balance Detail and Performance"}),": Use detailed meshes for visualization but simpler shapes for collision detection"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Test Regularly"}),": Validate your URDF with tools like ",(0,l.jsx)(e.code,{children:"check_urdf"})," and test in simulation"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.strong,{children:"Use Xacro"}),": For complex humanoid robots, use Xacro macros to avoid repetition"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"These practical examples provide a foundation for creating URDF models of humanoid robots for use in simulation, visualization, and control systems."}),"\n",(0,l.jsx)(e.h2,{id:"xacro-for-parameterized-descriptions",children:"Xacro for Parameterized Descriptions"}),"\n",(0,l.jsx)(e.h3,{id:"introduction-to-xacro",children:"Introduction to Xacro"}),"\n",(0,l.jsx)(e.p,{children:"Xacro (XML Macros) is a macro language for XML files that extends URDF with features like constants, properties, mathematical expressions, and reusable macros. Xacro is particularly useful for humanoid robots, which often have symmetrical components (left/right arms and legs) and repeated elements that can be parameterized."}),"\n",(0,l.jsxs)(e.p,{children:["Xacro files use the ",(0,l.jsx)(e.code,{children:".xacro"})," extension and are processed by the ",(0,l.jsx)(e.code,{children:"xacro"})," command-line tool to generate standard URDF files."]}),"\n",(0,l.jsx)(e.h3,{id:"basic-xacro-concepts",children:"Basic Xacro Concepts"}),"\n",(0,l.jsx)(e.h4,{id:"including-xacro",children:"Including Xacro"}),"\n",(0,l.jsx)(e.p,{children:"To use Xacro features, include the xacro namespace in your XML declaration:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_robot">\n'})}),"\n",(0,l.jsx)(e.h4,{id:"properties-and-constants",children:"Properties and Constants"}),"\n",(0,l.jsx)(e.p,{children:"Xacro allows you to define properties that can be reused throughout the file:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<xacro:property name="PI" value="3.14159"/>\n<xacro:property name="robot_mass" value="50.0"/>\n<xacro:property name="arm_length" value="0.4"/>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"mathematical-expressions",children:"Mathematical Expressions"}),"\n",(0,l.jsxs)(e.p,{children:["Xacro supports mathematical expressions using the ",(0,l.jsx)(e.code,{children:"${ }"})," syntax:"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<origin xyz="${arm_length} 0 0" rpy="0 ${PI/2} 0"/>\n<mass value="${robot_mass * 0.1}"/>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"xacro-macros",children:"Xacro Macros"}),"\n",(0,l.jsx)(e.p,{children:"Macros are reusable blocks of XML that can accept parameters:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<xacro:macro name="simple_cylinder" params="name radius length mass xyz *origin">\n  <link name="${name}">\n    <inertial>\n      <mass value="${mass}"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="${mass*(3*radius*radius + length*length)/12}"\n               ixy="0" ixz="0"\n               iyy="${mass*(3*radius*radius + length*length)/12}"\n               iyz="0"\n               izz="${mass*radius*radius/2}"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="${radius}" length="${length}"/>\n      </geometry>\n    </visual>\n    <collision>\n      <xacro:insert_block name="origin"/>\n      <geometry>\n        <cylinder radius="${radius}" length="${length}"/>\n      </geometry>\n    </collision>\n  </link>\n</xacro:macro>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"practical-xacro-example-for-humanoid-robot",children:"Practical Xacro Example for Humanoid Robot"}),"\n",(0,l.jsx)(e.p,{children:"Here's how to use Xacro to simplify the creation of a humanoid robot with symmetrical components:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_with_xacro">\n\n  \x3c!-- Define constants --\x3e\n  <xacro:property name="PI" value="3.14159"/>\n  <xacro:property name="mass_shoulder" value="1.0"/>\n  <xacro:property name="mass_arm" value="1.5"/>\n  <xacro:property name="arm_radius" value="0.04"/>\n  <xacro:property name="arm_length" value="0.4"/>\n  <xacro:property name="shoulder_radius" value="0.06"/>\n  <xacro:property name="shoulder_length" value="0.1"/>\n\n  \x3c!-- Macro for a simple cylinder link with inertial properties --\x3e\n  <xacro:macro name="cylinder_link" params="name radius length mass xyz rpy">\n    <link name="${name}">\n      <inertial>\n        <mass value="${mass}"/>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <inertia\n          ixx="${mass*(3*radius*radius + length*length)/12}"\n          ixy="0" ixz="0"\n          iyy="${mass*(3*radius*radius + length*length)/12}"\n          iyz="0"\n          izz="${mass*radius*radius/2}"/>\n      </inertial>\n      <visual>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <geometry>\n          <cylinder radius="${radius}" length="${length}"/>\n        </geometry>\n        <material name="gray">\n          <color rgba="0.5 0.5 0.5 1"/>\n        </material>\n      </visual>\n      <collision>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <geometry>\n          <cylinder radius="${radius}" length="${length}"/>\n        </geometry>\n      </collision>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Macro for a simple box link --\x3e\n  <xacro:macro name="box_link" params="name size_x size_y size_z mass xyz rpy">\n    <link name="${name}">\n      <inertial>\n        <mass value="${mass}"/>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <inertia\n          ixx="${mass*(size_y*size_y + size_z*size_z)/12}"\n          ixy="0" ixz="0"\n          iyy="${mass*(size_x*size_x + size_z*size_z)/12}"\n          iyz="0"\n          izz="${mass*(size_x*size_x + size_y*size_y)/12}"/>\n      </inertial>\n      <visual>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <geometry>\n          <box size="${size_x} ${size_y} ${size_z}"/>\n        </geometry>\n        <material name="white">\n          <color rgba="1 1 1 1"/>\n        </material>\n      </visual>\n      <collision>\n        <origin xyz="${xyz}" rpy="${rpy}"/>\n        <geometry>\n          <box size="${size_x} ${size_y} ${size_z}"/>\n        </geometry>\n      </collision>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Macro for an arm (either left or right) --\x3e\n  <xacro:macro name="arm" params="side position_x position_y">\n    \x3c!-- Shoulder joint --\x3e\n    <cylinder_link\n      name="${side}_shoulder"\n      radius="${shoulder_radius}"\n      length="${shoulder_length}"\n      mass="${mass_shoulder}"\n      xyz="0 0 0"\n      rpy="0 0 0"/>\n\n    <joint name="${side}_shoulder_yaw" type="revolute">\n      <parent link="torso"/>\n      <child link="${side}_shoulder"/>\n      <origin xyz="${position_x} ${position_y} 0.4" rpy="0 0 0"/>\n      <axis xyz="0 0 1"/>\n      <limit lower="${-PI/2}" upper="${PI/2}" effort="20" velocity="1.0"/>\n    </joint>\n\n    \x3c!-- Upper arm --\x3e\n    <cylinder_link\n      name="${side}_upper_arm"\n      radius="${arm_radius}"\n      length="${arm_length}"\n      mass="${mass_arm}"\n      xyz="0 0 ${-arm_length/2}"\n      rpy="0 0 0"/>\n\n    <joint name="${side}_shoulder_pitch" type="revolute">\n      <parent link="${side}_shoulder"/>\n      <child link="${side}_upper_arm"/>\n      <origin xyz="0 0 ${-shoulder_length/2}" rpy="0 0 0"/>\n      <axis xyz="1 0 0"/>\n      <limit lower="${-PI/2}" upper="${PI/2}" effort="20" velocity="1.0"/>\n    </joint>\n\n    \x3c!-- Lower arm --\x3e\n    <cylinder_link\n      name="${side}_lower_arm"\n      radius="${arm_radius*0.75}"\n      length="${arm_length*0.8}"\n      mass="${mass_arm*0.75}"\n      xyz="0 0 ${-arm_length*0.8/2}"\n      rpy="0 0 0"/>\n\n    <joint name="${side}_elbow" type="revolute">\n      <parent link="${side}_upper_arm"/>\n      <child link="${side}_lower_arm"/>\n      <origin xyz="0 0 ${-arm_length}" rpy="0 0 0"/>\n      <axis xyz="1 0 0"/>\n      <limit lower="${-PI/2}" upper="${PI/2}" effort="15" velocity="1.0"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Base link --\x3e\n  <cylinder_link\n    name="base_link"\n    radius="0.15"\n    length="1.0"\n    mass="10.0"\n    xyz="0 0 0.5"\n    rpy="0 0 0"/>\n\n  \x3c!-- Torso --\x3e\n  <box_link\n    name="torso"\n    size_x="0.3"\n    size_y="0.3"\n    size_z="0.6"\n    mass="8.0"\n    xyz="0 0 0.3"\n    rpy="0 0 0"/>\n\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 1.0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Use the arm macro to create both left and right arms --\x3e\n  <xacro:arm side="left" position_x="0.15" position_y="0.1"/>\n  <xacro:arm side="right" position_x="0.15" position_y="-0.1"/>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.02"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n      <material name="skin_color">\n        <color rgba="0.9 0.8 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n    </collision>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.6" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="${-PI/4}" upper="${PI/4}" effort="10" velocity="1.5"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"advanced-xacro-features",children:"Advanced Xacro Features"}),"\n",(0,l.jsx)(e.h4,{id:"conditional-statements",children:"Conditional Statements"}),"\n",(0,l.jsxs)(e.p,{children:["Xacro supports conditional statements using the ",(0,l.jsx)(e.code,{children:"if"})," attribute:"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<xacro:macro name="conditional_part" params="include_sensor:=false">\n  <xacro:if value="${include_sensor}">\n    <link name="sensor_mount">\n      \x3c!-- Sensor mount definition --\x3e\n    </link>\n  </xacro:if>\n</xacro:macro>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"including-other-xacro-files",children:"Including Other Xacro Files"}),"\n",(0,l.jsx)(e.p,{children:"You can include other xacro files to modularize your robot definition:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<xacro:include filename="$(find robot_description)/urdf/sensors.urdf.xacro"/>\n<xacro:include filename="$(find robot_description)/urdf/arms.urdf.xacro"/>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"loops",children:"Loops"}),"\n",(0,l.jsx)(e.p,{children:"Xacro supports loops for repetitive structures:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<xacro:macro name="spine_links" params="count spacing">\n  <xacro:property name="link_mass" value="1.0"/>\n  <xacro:property name="link_radius" value="0.05"/>\n  <xacro:property name="link_length" value="0.1"/>\n\n  <xacro:property name="i" value="0"/>\n  <xacro:while value="${i < count}">\n    <cylinder_link\n      name="vertebra_${i}"\n      radius="${link_radius}"\n      length="${link_length}"\n      mass="${link_mass}"\n      xyz="0 0 ${i * spacing}"\n      rpy="0 0 0"/>\n\n    <xacro:if value="${i > 0}">\n      <joint name="connection_${i}" type="fixed">\n        <parent link="vertebra_${i - 1}"/>\n        <child link="vertebra_${i}"/>\n        <origin xyz="0 0 ${spacing}" rpy="0 0 0"/>\n      </joint>\n    </xacro:if>\n\n    <xacro:property name="i" value="${i + 1}"/>\n  </xacro:while>\n</xacro:macro>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"benefits-of-using-xacro-for-humanoid-robots",children:"Benefits of Using Xacro for Humanoid Robots"}),"\n",(0,l.jsx)(e.h4,{id:"reduced-repetition",children:"Reduced Repetition"}),"\n",(0,l.jsx)(e.p,{children:"Xacro significantly reduces code duplication, especially for symmetrical components like arms and legs."}),"\n",(0,l.jsx)(e.h4,{id:"parameterization",children:"Parameterization"}),"\n",(0,l.jsx)(e.p,{children:"Changes to dimensions, masses, or other properties can be made in one place and automatically propagated throughout the model."}),"\n",(0,l.jsx)(e.h4,{id:"modularity",children:"Modularity"}),"\n",(0,l.jsx)(e.p,{children:"Complex robots can be broken down into modular components that can be included as needed."}),"\n",(0,l.jsx)(e.h4,{id:"readability",children:"Readability"}),"\n",(0,l.jsx)(e.p,{children:"Xacro makes URDF files more readable by separating constants and logic from the structural definition."}),"\n",(0,l.jsx)(e.h3,{id:"converting-xacro-to-urdf",children:"Converting Xacro to URDF"}),"\n",(0,l.jsx)(e.p,{children:"To convert a Xacro file to URDF, use the xacro command:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-bash",children:"xacro input_file.urdf.xacro > output_file.urdf\n"})}),"\n",(0,l.jsx)(e.p,{children:"Or in ROS 2:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-bash",children:"ros2 run xacro xacro input_file.urdf.xacro -o output_file.urdf\n"})}),"\n",(0,l.jsx)(e.h3,{id:"best-practices-for-xacro",children:"Best Practices for Xacro"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Use Meaningful Property Names"}),": Choose descriptive names for your properties to make the code more readable."]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Group Related Parameters"}),": Organize related parameters together in property blocks."]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Document Your Macros"}),": Add comments explaining what each macro does and what parameters it expects."]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Validate Your Output"}),": Always check that the generated URDF is valid and represents your intended robot."]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.strong,{children:"Use Units Consistently"}),": Stick to consistent units (SI units are standard in ROS)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"Xacro is an essential tool for creating complex humanoid robot models efficiently, reducing redundancy, and making the URDF files more maintainable and flexible."}),"\n",(0,l.jsx)(e.h2,{id:"urdf-integration-with-simulation-environments",children:"URDF Integration with Simulation Environments"}),"\n",(0,l.jsx)(e.h3,{id:"introduction-to-simulation-integration",children:"Introduction to Simulation Integration"}),"\n",(0,l.jsx)(e.p,{children:"URDF models are essential for simulating humanoid robots in various environments. Simulation allows developers to test robot behaviors, validate control algorithms, and verify kinematic models before deploying to physical hardware. The integration between URDF and simulation environments is critical for accurate and efficient simulation."}),"\n",(0,l.jsx)(e.h3,{id:"gazebo-simulation-environment",children:"Gazebo Simulation Environment"}),"\n",(0,l.jsx)(e.p,{children:"Gazebo is one of the most widely used simulation environments for robotics, particularly in the ROS ecosystem. URDF models integrate with Gazebo through several mechanisms:"}),"\n",(0,l.jsx)(e.h4,{id:"gazebo-specific-tags-in-urdf",children:"Gazebo-Specific Tags in URDF"}),"\n",(0,l.jsx)(e.p,{children:"URDF files can include Gazebo-specific tags that define how the robot behaves in simulation:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="link_name">\n  <material>Gazebo/Blue</material>\n  <mu1>0.2</mu1>\n  <mu2>0.2</mu2>\n  <kp>1000000.0</kp>\n  <kd>100.0</kd>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"gazebo-plugins",children:"Gazebo Plugins"}),"\n",(0,l.jsx)(e.p,{children:"Gazebo plugins can be attached to URDF models to provide specific functionality:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n    <robotNamespace>/humanoid_robot</robotNamespace>\n    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h4,{id:"joint-transmission-elements",children:"Joint Transmission Elements"}),"\n",(0,l.jsx)(e.p,{children:"For proper control in simulation, URDF models need transmission elements:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<transmission name="left_elbow_trans">\n  <type>transmission_interface/SimpleTransmission</type>\n  <joint name="left_elbow">\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n  </joint>\n  <actuator name="left_elbow_motor">\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n    <mechanicalReduction>1</mechanicalReduction>\n  </actuator>\n</transmission>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"integration-process",children:"Integration Process"}),"\n",(0,l.jsx)(e.h4,{id:"1-model-conversion",children:"1. Model Conversion"}),"\n",(0,l.jsx)(e.p,{children:"When a URDF model is loaded into Gazebo, it undergoes several transformations:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Links become rigid bodies with mass and inertia properties"}),"\n",(0,l.jsx)(e.li,{children:"Joints become constraint systems that limit motion"}),"\n",(0,l.jsx)(e.li,{children:"Visual elements become renderable objects"}),"\n",(0,l.jsx)(e.li,{children:"Collision elements become physics collision primitives"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"2-physics-properties",children:"2. Physics Properties"}),"\n",(0,l.jsx)(e.p,{children:"The inertial properties defined in URDF directly influence the physics simulation:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Mass values affect how the robot responds to forces"}),"\n",(0,l.jsx)(e.li,{children:"Inertia tensors affect rotational dynamics"}),"\n",(0,l.jsx)(e.li,{children:"Friction coefficients (defined in Gazebo tags) affect contact behavior"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"3-sensor-integration",children:"3. Sensor Integration"}),"\n",(0,l.jsx)(e.p,{children:"Sensors defined in URDF are instantiated in the simulation environment:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<link name="camera_link">\n  <visual>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.1"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n  </inertial>\n</link>\n\n<gazebo reference="camera_link">\n  <sensor type="camera" name="camera1">\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>800</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_link_optical</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"other-simulation-environments",children:"Other Simulation Environments"}),"\n",(0,l.jsx)(e.h4,{id:"webots",children:"Webots"}),"\n",(0,l.jsx)(e.p,{children:"Webots is another popular robotics simulator that can import URDF models. The integration process involves:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Converting URDF to Webots PROTO format"}),"\n",(0,l.jsx)(e.li,{children:"Mapping joint types and limits"}),"\n",(0,l.jsx)(e.li,{children:"Preserving visual and collision properties"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"mujoco",children:"Mujoco"}),"\n",(0,l.jsx)(e.p,{children:"Mujoco is a physics engine often used for robotics research. URDF models can be converted to Mujoco format, though this may require some manual adjustments to ensure accurate physics simulation."}),"\n",(0,l.jsx)(e.h4,{id:"pybullet",children:"PyBullet"}),"\n",(0,l.jsx)(e.p,{children:"PyBullet is a Python-based physics simulator that can directly load URDF files. It's commonly used for machine learning research involving robotics."}),"\n",(0,l.jsx)(e.h3,{id:"best-practices-for-simulation-integration",children:"Best Practices for Simulation Integration"}),"\n",(0,l.jsx)(e.h4,{id:"1-accurate-physical-properties",children:"1. Accurate Physical Properties"}),"\n",(0,l.jsx)(e.p,{children:"Ensure that mass, inertia, and friction values in your URDF are realistic:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Use CAD software to calculate accurate inertial properties"}),"\n",(0,l.jsx)(e.li,{children:"Verify that total robot mass matches the physical robot"}),"\n",(0,l.jsx)(e.li,{children:"Set appropriate friction coefficients for different surfaces"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"2-simplified-collision-models",children:"2. Simplified Collision Models"}),"\n",(0,l.jsx)(e.p,{children:"Use simplified geometries for collision detection to improve simulation performance:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Approximate complex shapes with multiple simple primitives"}),"\n",(0,l.jsx)(e.li,{children:"Use bounding boxes instead of detailed meshes for collision"}),"\n",(0,l.jsx)(e.li,{children:"Balance accuracy with computational efficiency"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"3-proper-joint-limits",children:"3. Proper Joint Limits"}),"\n",(0,l.jsx)(e.p,{children:"Set realistic joint limits based on the physical robot:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Include safety margins to prevent damage during simulation"}),"\n",(0,l.jsx)(e.li,{children:"Consider the effect of joint limits on motion planning"}),"\n",(0,l.jsx)(e.li,{children:"Verify that limits are consistent with the physical robot"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"4-sensor-placement",children:"4. Sensor Placement"}),"\n",(0,l.jsx)(e.p,{children:"Carefully consider sensor placement in simulation:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Position sensors as they are on the physical robot"}),"\n",(0,l.jsx)(e.li,{children:"Configure sensor parameters to match physical sensors"}),"\n",(0,l.jsx)(e.li,{children:"Consider the field of view and range of sensors"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"simulation-specific-considerations-for-humanoid-robots",children:"Simulation-Specific Considerations for Humanoid Robots"}),"\n",(0,l.jsx)(e.h4,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,l.jsx)(e.p,{children:"Humanoid robots require special attention to balance in simulation:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Accurate center of mass calculation is critical"}),"\n",(0,l.jsx)(e.li,{children:"Proper foot contact modeling for stable stance"}),"\n",(0,l.jsx)(e.li,{children:"Realistic actuator dynamics to simulate real-world limitations"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"complex-kinematics",children:"Complex Kinematics"}),"\n",(0,l.jsx)(e.p,{children:"Humanoid robots have complex kinematic chains that require:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Accurate joint placement and orientation"}),"\n",(0,l.jsx)(e.li,{children:"Proper handling of closed-loop kinematic chains"}),"\n",(0,l.jsx)(e.li,{children:"Consideration of kinematic singularities"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"computational-performance",children:"Computational Performance"}),"\n",(0,l.jsx)(e.p,{children:"Simulating humanoid robots can be computationally intensive:"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Optimize collision geometry for performance"}),"\n",(0,l.jsx)(e.li,{children:"Use appropriate solver parameters"}),"\n",(0,l.jsx)(e.li,{children:"Consider simplifying models for faster simulation"}),"\n"]}),"\n",(0,l.jsx)(e.h3,{id:"launching-robots-in-simulation",children:"Launching Robots in Simulation"}),"\n",(0,l.jsx)(e.p,{children:"To launch a URDF model in Gazebo simulation, you typically use a launch file:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<launch>\n  \x3c!-- Load the URDF into the parameter server --\x3e\n  <param name="robot_description"\n         command="$(find xacro)/xacro $(find humanoid_robot_description)/urdf/humanoid_robot.urdf.xacro"/>\n\n  \x3c!-- Spawn the robot in Gazebo --\x3e\n  <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_model"\n        args="-param robot_description -urdf -model humanoid_robot" />\n\n  \x3c!-- Start Gazebo --\x3e\n  <include file="$(find gazebo_ros)/launch/empty_world.launch">\n    <arg name="paused" value="false"/>\n    <arg name="use_sim_time" value="true"/>\n    <arg name="gui" value="true"/>\n    <arg name="headless" value="false"/>\n    <arg name="debug" value="false"/>\n  </include>\n</launch>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"troubleshooting-simulation-issues",children:"Troubleshooting Simulation Issues"}),"\n",(0,l.jsx)(e.h4,{id:"robot-falls-through-ground",children:"Robot Falls Through Ground"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Check that all links have proper mass and inertia values"}),"\n",(0,l.jsx)(e.li,{children:"Verify that collision elements are defined for ground-contacting links"}),"\n",(0,l.jsx)(e.li,{children:"Ensure that the physics engine is properly configured"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"joints-behaving-unexpectedly",children:"Joints Behaving Unexpectedly"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Verify joint limits and types match the physical robot"}),"\n",(0,l.jsx)(e.li,{children:"Check that joint origins are correctly specified"}),"\n",(0,l.jsx)(e.li,{children:"Ensure transmission elements are properly defined"}),"\n"]}),"\n",(0,l.jsx)(e.h4,{id:"poor-simulation-performance",children:"Poor Simulation Performance"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Simplify collision geometry"}),"\n",(0,l.jsx)(e.li,{children:"Reduce the number of complex meshes"}),"\n",(0,l.jsx)(e.li,{children:"Adjust physics engine parameters (step size, solver type)"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"The integration of URDF models with simulation environments is a critical step in developing and testing humanoid robots. Proper integration ensures that simulation results accurately reflect the behavior of the physical robot, enabling effective development and validation of control algorithms and behaviors."}),"\n",(0,l.jsx)(e.h2,{id:"sample-urdf-code-snippets",children:"Sample URDF Code Snippets"}),"\n",(0,l.jsx)(e.h3,{id:"basic-robot-structure",children:"Basic Robot Structure"}),"\n",(0,l.jsx)(e.p,{children:"Here's a minimal URDF file that demonstrates the basic structure:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.2 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.2 0.2 0.2"/>\n      </geometry>\n    </collision>\n  </link>\n</robot>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"complete-joint-example",children:"Complete Joint Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's a more complete example showing how to connect two links with a joint:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="two_link_robot">\n  \x3c!-- First link --\x3e\n  <link name="link1">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.2"/>\n      </geometry>\n      <material name="red">\n        <color rgba="1 0 0 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Second link --\x3e\n  <link name="link2">\n    <inertial>\n      <mass value="0.5"/>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.001"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.3"/>\n      </geometry>\n      <material name="green">\n        <color rgba="0 1 0 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.3"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint connecting the two links --\x3e\n  <joint name="joint1" type="revolute">\n    <parent link="link1"/>\n    <child link="link2"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"humanoid-torso-example",children:"Humanoid Torso Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's a more complex example showing a humanoid torso with multiple attachments:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_torso">\n  \x3c!-- Torso link --\x3e\n  <link name="torso">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <inertia ixx="0.8" ixy="0" ixz="0" iyy="0.8" iyz="0" izz="0.2"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.6"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1 1 1 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 0.3" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 0.6"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Head attachment --\x3e\n  <link name="head">\n    <inertial>\n      <mass value="2.0"/>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <inertia ixx="0.02" ixy="0" ixz="0" iyy="0.02" iyz="0" izz="0.02"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.9 0.8 0.7 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\n      <geometry>\n        <sphere radius="0.15"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Neck joint --\x3e\n  <joint name="neck_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.6" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.785" upper="0.785" effort="5" velocity="2"/>\n  </joint>\n\n  \x3c!-- Left shoulder attachment --\x3e\n  <link name="left_shoulder">\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <inertia ixx="0.005" ixy="0" ixz="0" iyy="0.005" iyz="0" izz="0.001"/>\n    </inertial>\n\n    <visual>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.5 0.5 0.5 1"/>\n      </material>\n    </visual>\n\n    <collision>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <geometry>\n        <cylinder radius="0.05" length="0.1"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Left shoulder joint --\x3e\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_shoulder"/>\n    <origin xyz="0.15 0.15 0.4" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="20" velocity="1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"sensor-attachment-example",children:"Sensor Attachment Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's how to attach a camera sensor to a robot:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Camera link --\x3e\n<link name="camera_link">\n  <inertial>\n    <mass value="0.1"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.0001"/>\n  </inertial>\n\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n    <material name="black">\n      <color rgba="0 0 0 1"/>\n    </material>\n  </visual>\n\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n</link>\n\n\x3c!-- Joint to attach camera to head --\x3e\n<joint name="camera_joint" type="fixed">\n  <parent link="head"/>\n  <child link="camera_link"/>\n  <origin xyz="0.1 0 0.05" rpy="0 0 0"/>\n</joint>\n\n\x3c!-- Gazebo-specific sensor definition --\x3e\n<gazebo reference="camera_link">\n  <sensor type="camera" name="camera1">\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>800</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.01</near>\n        <far>300</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <alwaysOn>true</alwaysOn>\n      <updateRate>0.0</updateRate>\n      <cameraName>camera1</cameraName>\n      <imageTopicName>image_raw</imageTopicName>\n      <cameraInfoTopicName>camera_info</cameraInfoTopicName>\n      <frameName>camera_link</frameName>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"transmission-example",children:"Transmission Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's how to define transmissions for joint control:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example transmission for a joint --\x3e\n<transmission name="left_elbow_trans">\n  <type>transmission_interface/SimpleTransmission</type>\n  <joint name="left_elbow_joint">\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n  </joint>\n  <actuator name="left_elbow_motor">\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\n    <mechanicalReduction>1</mechanicalReduction>\n  </actuator>\n</transmission>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"gazebo-specific-properties",children:"Gazebo-Specific Properties"}),"\n",(0,l.jsx)(e.p,{children:"Here's how to add Gazebo-specific properties to a link:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot">\n  <material>Gazebo/White</material>\n  <mu1>0.8</mu1>\n  <mu2>0.8</mu2>\n  <kp>1000000.0</kp>\n  <kd>100.0</kd>\n  <fdir1>1 0 0</fdir1>\n</gazebo>\n'})}),"\n",(0,l.jsx)(e.h3,{id:"complete-humanoid-hand-example",children:"Complete Humanoid Hand Example"}),"\n",(0,l.jsx)(e.p,{children:"Here's a more complex example showing a simple hand model:"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Palm link --\x3e\n<link name="left_palm">\n  <inertial>\n    <mass value="0.3"/>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n  </inertial>\n\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.1 0.08 0.02"/>\n    </geometry>\n    <material name="skin">\n      <color rgba="0.9 0.8 0.7 1"/>\n    </material>\n  </visual>\n\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="0.1 0.08 0.02"/>\n    </geometry>\n  </collision>\n</link>\n\n\x3c!-- Thumb --\x3e\n<link name="left_thumb">\n  <inertial>\n    <mass value="0.05"/>\n    <origin xyz="0 0 -0.025" rpy="0 0 0"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.00005"/>\n  </inertial>\n\n  <visual>\n    <origin xyz="0 0 -0.025" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.01" length="0.05"/>\n    </geometry>\n    <material name="skin">\n      <color rgba="0.9 0.8 0.7 1"/>\n    </material>\n  </visual>\n\n  <collision>\n    <origin xyz="0 0 -0.025" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.01" length="0.05"/>\n    </geometry>\n  </collision>\n</link>\n\n<joint name="left_thumb_joint" type="revolute">\n  <parent link="left_palm"/>\n  <child link="left_thumb"/>\n  <origin xyz="0.04 0.03 0" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="0" upper="1.57" effort="2" velocity="1"/>\n</joint>\n\n\x3c!-- Index finger --\x3e\n<link name="left_index">\n  <inertial>\n    <mass value="0.04"/>\n    <origin xyz="0 0 -0.03" rpy="0 0 0"/>\n    <inertia ixx="0.0001" ixy="0" ixz="0" iyy="0.0001" iyz="0" izz="0.00004"/>\n  </inertial>\n\n  <visual>\n    <origin xyz="0 0 -0.03" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.008" length="0.06"/>\n    </geometry>\n    <material name="skin">\n      <color rgba="0.9 0.8 0.7 1"/>\n    </material>\n  </visual>\n\n  <collision>\n    <origin xyz="0 0 -0.03" rpy="0 0 0"/>\n    <geometry>\n      <cylinder radius="0.008" length="0.06"/>\n    </geometry>\n  </collision>\n</link>\n\n<joint name="left_index_joint" type="revolute">\n  <parent link="left_palm"/>\n  <child link="left_index"/>\n  <origin xyz="0.03 0.01 0" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="0" upper="1.57" effort="2" velocity="1"/>\n</joint>\n'})}),"\n",(0,l.jsx)(e.p,{children:"These code snippets demonstrate various aspects of URDF modeling for humanoid robots, from basic structure to complex multi-link systems with sensors and transmissions. They can serve as templates for building more complex humanoid robot models."})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}}}]);